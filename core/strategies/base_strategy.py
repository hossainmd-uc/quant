"""
Base Strategy Framework
======================

This module provides the foundational classes and interfaces for all trading strategies.
It includes signal generation, risk management, and performance tracking capabilities.
"""

import pandas as pd
import numpy as np
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Union, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import warnings

@dataclass
class StrategySignal:
    """
    Represents a trading signal generated by a strategy.
    
    Attributes:
        timestamp: When the signal was generated
        symbol: The asset symbol
        signal_type: 'BUY', 'SELL', or 'HOLD'
        strength: Signal strength (0-1)
        price: Price at signal generation
        quantity: Suggested quantity
        metadata: Additional signal information
    """
    timestamp: datetime
    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: float  # 0.0 to 1.0
    price: float
    quantity: int
    metadata: Optional[Dict] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}
        
        # Validate signal strength
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError("Signal strength must be between 0.0 and 1.0")
        
        # Validate signal type
        if self.signal_type not in ['BUY', 'SELL', 'HOLD']:
            raise ValueError("Signal type must be 'BUY', 'SELL', or 'HOLD'")

class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    This class provides the common interface and functionality that all strategies
    must implement, including data management, signal generation, risk management,
    and performance tracking.
    """
    
    def __init__(self, 
                 name: str,
                 parameters: Optional[Dict] = None,
                 risk_management: Optional[Dict] = None,
                 lookback_period: int = 252):
        """
        Initialize the base strategy.
        
        Args:
            name: Strategy name
            parameters: Strategy-specific parameters
            risk_management: Risk management parameters
            lookback_period: Number of periods to look back for calculations
        """
        self.name = name
        self.parameters = parameters or {}
        self.risk_management = risk_management or {}
        self.lookback_period = lookback_period
        
        # Strategy state
        self.is_initialized = False
        self.signals = []
        self.positions = {}
        self.performance_metrics = {}
        
        # Data storage
        self.data = {}
        self.indicators = {}
        
        # Risk management defaults
        self.max_position_size = self.risk_management.get('max_position_size', 0.05)  # 5% of portfolio
        self.stop_loss_pct = self.risk_management.get('stop_loss_pct', 0.02)  # 2% stop loss
        self.take_profit_pct = self.risk_management.get('take_profit_pct', 0.04)  # 4% take profit
        
    def add_data(self, symbol: str, data: pd.DataFrame) -> None:
        """
        Add price data for a symbol.
        
        Args:
            symbol: The asset symbol
            data: DataFrame with OHLCV data
        """
        required_columns = ['Open', 'High', 'Low', 'Close', 'Volume']
        if not all(col in data.columns for col in required_columns):
            raise ValueError(f"Data must contain columns: {required_columns}")
        
        self.data[symbol] = data.copy()
        self.indicators[symbol] = {}
        
    def calculate_returns(self, symbol: str, periods: int = 1) -> pd.Series:
        """Calculate returns for a symbol."""
        if symbol not in self.data:
            raise ValueError(f"No data available for symbol: {symbol}")
        
        prices = self.data[symbol]['Close']
        return prices.pct_change(periods=periods).dropna()
    
    def calculate_volatility(self, symbol: str, window: int = 20) -> pd.Series:
        """Calculate rolling volatility."""
        returns = self.calculate_returns(symbol)
        return returns.rolling(window=window).std() * np.sqrt(252)
    
    def calculate_moving_average(self, symbol: str, window: int, price_type: str = 'Close') -> pd.Series:
        """Calculate moving average."""
        if symbol not in self.data:
            raise ValueError(f"No data available for symbol: {symbol}")
        
        prices = self.data[symbol][price_type]
        return prices.rolling(window=window).mean()
    
    def calculate_bollinger_bands(self, symbol: str, window: int = 20, num_std: float = 2.0) -> Dict[str, pd.Series]:
        """Calculate Bollinger Bands."""
        ma = self.calculate_moving_average(symbol, window)
        std = self.data[symbol]['Close'].rolling(window=window).std()
        
        return {
            'middle': ma,
            'upper': ma + (std * num_std),
            'lower': ma - (std * num_std)
        }
    
    def calculate_rsi(self, symbol: str, window: int = 14) -> pd.Series:
        """Calculate Relative Strength Index."""
        if symbol not in self.data:
            raise ValueError(f"No data available for symbol: {symbol}")
        
        prices = self.data[symbol]['Close']
        delta = prices.diff()
        
        gain = delta.where(delta > 0, 0.0)
        loss = -delta.where(delta < 0, 0.0)
        
        avg_gain = gain.rolling(window=window).mean()
        avg_loss = loss.rolling(window=window).mean()
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
    
    def calculate_macd(self, symbol: str, fast: int = 12, slow: int = 26, signal: int = 9) -> Dict[str, pd.Series]:
        """Calculate MACD indicator."""
        if symbol not in self.data:
            raise ValueError(f"No data available for symbol: {symbol}")
        
        prices = self.data[symbol]['Close']
        
        ema_fast = prices.ewm(span=fast).mean()
        ema_slow = prices.ewm(span=slow).mean()
        
        macd_line = ema_fast - ema_slow
        signal_line = macd_line.ewm(span=signal).mean()
        histogram = macd_line - signal_line
        
        return {
            'macd': macd_line,
            'signal': signal_line,
            'histogram': histogram
        }
    
    def apply_risk_management(self, signal: StrategySignal) -> StrategySignal:
        """
        Apply risk management rules to a signal.
        
        Args:
            signal: The original signal
            
        Returns:
            Modified signal with risk management applied
        """
        # Check position size limits
        if signal.signal_type in ['BUY', 'SELL']:
            # Implement position sizing based on volatility
            volatility = self.calculate_volatility(signal.symbol).iloc[-1]
            if not np.isnan(volatility):
                # Adjust position size based on volatility
                vol_adj_factor = min(1.0, 0.2 / volatility)  # Target 20% volatility
                signal.quantity = int(signal.quantity * vol_adj_factor)
        
        # Add stop loss and take profit to metadata
        if signal.metadata is None:
            signal.metadata = {}
        
        if signal.signal_type == 'BUY':
            signal.metadata['stop_loss'] = signal.price * (1 - self.stop_loss_pct)
            signal.metadata['take_profit'] = signal.price * (1 + self.take_profit_pct)
        elif signal.signal_type == 'SELL':
            signal.metadata['stop_loss'] = signal.price * (1 + self.stop_loss_pct)
            signal.metadata['take_profit'] = signal.price * (1 - self.take_profit_pct)
        
        return signal
    
    def validate_signal(self, signal: StrategySignal) -> bool:
        """
        Validate a signal before execution.
        
        Args:
            signal: The signal to validate
            
        Returns:
            True if signal is valid, False otherwise
        """
        # Check if we have recent data
        if signal.symbol not in self.data:
            return False
        
        # Check if signal strength is sufficient
        min_strength = self.parameters.get('min_signal_strength', 0.5)
        if signal.strength < min_strength:
            return False
        
        # Check position limits
        current_position = self.positions.get(signal.symbol, 0)
        max_position = self.parameters.get('max_position_per_symbol', 10000)
        
        if signal.signal_type == 'BUY' and current_position >= max_position:
            return False
        elif signal.signal_type == 'SELL' and current_position <= -max_position:
            return False
        
        return True
    
    def update_position(self, signal: StrategySignal) -> None:
        """Update position tracking after signal execution."""
        if signal.symbol not in self.positions:
            self.positions[signal.symbol] = 0
        
        if signal.signal_type == 'BUY':
            self.positions[signal.symbol] += signal.quantity
        elif signal.signal_type == 'SELL':
            self.positions[signal.symbol] -= signal.quantity
    
    def calculate_performance_metrics(self, returns: pd.Series) -> Dict:
        """
        Calculate performance metrics for the strategy.
        
        Args:
            returns: Series of strategy returns
            
        Returns:
            Dictionary of performance metrics
        """
        if len(returns) == 0:
            return {}
        
        # Basic metrics
        total_return = (1 + returns).prod() - 1
        annual_return = (1 + returns.mean()) ** 252 - 1
        annual_volatility = returns.std() * np.sqrt(252)
        
        # Risk-adjusted metrics
        sharpe_ratio = annual_return / annual_volatility if annual_volatility > 0 else 0
        
        # Drawdown analysis
        cumulative_returns = (1 + returns).cumprod()
        running_max = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - running_max) / running_max
        max_drawdown = drawdown.min()
        
        # Additional metrics
        win_rate = (returns > 0).sum() / len(returns)
        avg_win = returns[returns > 0].mean() if (returns > 0).any() else 0
        avg_loss = returns[returns < 0].mean() if (returns < 0).any() else 0
        profit_factor = abs(avg_win / avg_loss) if avg_loss != 0 else 0
        
        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'profit_factor': profit_factor,
            'num_trades': len(returns)
        }
    
    @abstractmethod
    def generate_signals(self, timestamp: datetime) -> List[StrategySignal]:
        """
        Generate trading signals for the given timestamp.
        
        This method must be implemented by all strategy subclasses.
        
        Args:
            timestamp: The timestamp for signal generation
            
        Returns:
            List of StrategySignal objects
        """
        pass
    
    @abstractmethod
    def initialize(self) -> None:
        """
        Initialize the strategy.
        
        This method must be implemented by all strategy subclasses.
        It should perform any necessary setup before signal generation.
        """
        pass
    
    def run_backtest(self, start_date: datetime, end_date: datetime) -> Dict:
        """
        Run a backtest of the strategy.
        
        Args:
            start_date: Start date for backtest
            end_date: End date for backtest
            
        Returns:
            Dictionary containing backtest results
        """
        if not self.is_initialized:
            self.initialize()
        
        # Get all timestamps in the date range
        all_timestamps = set()
        for symbol_data in self.data.values():
            mask = (symbol_data.index >= start_date) & (symbol_data.index <= end_date)
            all_timestamps.update(symbol_data.index[mask])
        
        all_timestamps = sorted(all_timestamps)
        
        # Generate signals for each timestamp
        all_signals = []
        for timestamp in all_timestamps:
            try:
                signals = self.generate_signals(timestamp)
                for signal in signals:
                    # Apply risk management
                    signal = self.apply_risk_management(signal)
                    
                    # Validate signal
                    if self.validate_signal(signal):
                        all_signals.append(signal)
                        self.update_position(signal)
                        
            except Exception as e:
                warnings.warn(f"Error generating signals for {timestamp}: {e}")
                continue
        
        # Calculate returns (simplified)
        returns = []
        for signal in all_signals:
            # This is a simplified return calculation
            # In a real implementation, you'd track actual P&L
            if signal.signal_type == 'BUY':
                returns.append(0.01 * signal.strength)  # Simplified positive return
            elif signal.signal_type == 'SELL':
                returns.append(-0.01 * signal.strength)  # Simplified negative return
        
        strategy_returns = pd.Series(returns, index=[s.timestamp for s in all_signals])
        
        # Calculate performance metrics
        performance = self.calculate_performance_metrics(strategy_returns)
        
        return {
            'signals': all_signals,
            'returns': strategy_returns,
            'performance': performance,
            'positions': self.positions.copy()
        }
    
    def get_strategy_info(self) -> Dict:
        """Get strategy information and current state."""
        return {
            'name': self.name,
            'parameters': self.parameters,
            'risk_management': self.risk_management,
            'is_initialized': self.is_initialized,
            'num_signals': len(self.signals),
            'positions': self.positions,
            'performance_metrics': self.performance_metrics
        } 